{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Packet Ripper\u00b6","text":"<p>Packet Ripper   is your all-in-one solution for advanced network packet analysis. Seamlessly integrated with the Windows Winsock API using a dynamic link library (DLL), this powerful tool captures and logs application-level packets in real-time. Unveil the hexadecimal representation of your data with a built-in hex editor, showcasing values dynamically in various types. Take control of your packet interpretation using the sophisticated built-in parser, or employ our Python API for real-time scripting flexibility.</p> <ul> <li>To quickly get started as a new user, check out our  Getting Started Guide</li> <li>To learn about the user interface, check out the more extensive  User Guide</li> </ul> <p>Of course, if you just have some questions, you might find our  discussions on slack  helpful, or as always contact us with any questions.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to Packet Ripper! This introduction document is meant to quickly guide you over some of the most common uses of Packet Ripper. If you're interested in more detailed information, check out the  User Guide.</p>"},{"location":"getting-started/#installing-packet-ripper","title":"Installing Packet Ripper\u00b6","text":"<p>The download links you receive after purchasing expire after 72 hours but as long as you have  active support  you can  request download links  any time.</p> <p>To install on Windows, use the installer linked from the email you received after purchase. During the install process, you'll need to choose whether to install globally or to your local user path.</p>"},{"location":"getting-started/#license","title":"License\u00b6","text":"<p>When you first run Packet Ripper, it will prompt you for your license key. You should have received your license key via the same email that included your download links. If not, please contact  support.</p>"},{"location":"getting-started/#attaching","title":"Attaching\u00b6","text":"<p>While there are more ways than shown here, the most common ways to open a file are:</p> <ul> <li>Attach and Inject ( Use the built-in injector)</li> <li>Just Attach (To use your own personal Injector)</li> <li>Proxy (Coming Soon) </li> </ul> <p>You can change injection settings for bypassing detection mechanism</p>"},{"location":"getting-started/#ui-basics","title":"UI Basics\u00b6","text":"<p>By default, you'll see four main areas in Packet Ripper:</p> <ol> <li>Proxy (With multiple types of Winsock packet logging)</li> <li>Parser (To parse packets show in proxy)</li> <li>Hex Editor (To dynamically edit packets and resend them)</li> <li>Logger (Shows the logs of both Packet Ripper and the Target process)</li> </ol> <p></p> <p>Make sure to check out the many configuration for the above in the settings menu.</p>"},{"location":"getting-started/#updates","title":"Updates\u00b6","text":"<p>By default, Packet Ripper is configured to automatically update itself to any new stable releases. However, during changes to the update system, we will send updates trough an email download link.</p>"},{"location":"getting-started/#whats-next","title":"What's next?\u00b6","text":"<ul> <li>Read the rest of the more detailed  User Guide</li> <li>Join one of our  Slack</li> <li>Check out the FAQ</li> <li>Contact us regarding questions, we are here to help</li> </ul>"},{"location":"user-guide/","title":"User Guide\u00b6","text":"<p>Welcome to the Packet Ripper User Guide. You'll notice two menus here. On the right is the table of contents for this main page of the user manual. On the left are links to larger topics that have their own pages, including but not limited to:</p> <ul> <li>Proxy</li> <li>Parsers</li> <li>Hex-Editor</li> <li>Logger</li> <li>API</li> </ul>"},{"location":"user-guide/api/","title":"Python Encryption/Decryption API Documentation","text":"<p>Welcome to the Python Encryption/Decryption API Documentation for Packet Ripper! This documentation provides detailed information on how to use the Python API for encryption and decryption in Packet Ripper.</p>"},{"location":"user-guide/api/#overview","title":"Overview","text":"<p>The Python Encryption/Decryption API allows users to customize the encryption and decryption process for intercepted network packets in Packet Ripper. By providing a Python script with encryption and decryption functions, users can integrate their own encryption algorithms or techniques into the Packet Ripper proxy in real-time.</p>"},{"location":"user-guide/api/#key-components","title":"Key Components","text":"<ul> <li> <p>Encryption/Decryption Script: A Python script containing encryption and decryption functions.</p> </li> <li> <p>Settings Configuration: Configuration settings within Packet Ripper to specify the path to the Python script and the names of the encryption and decryption functions.</p> </li> <li> <p>Integration with Packet Ripper: The Python API seamlessly integrates with the Packet Ripper proxy, enabling on-the-fly encryption and decryption of intercepted network packets.</p> </li> </ul>"},{"location":"user-guide/api/#usage","title":"Usage","text":"<p>To utilize the Python Encryption/Decryption API in Packet Ripper, follow these steps:</p> <ol> <li> <p>Create Encryption/Decryption Script: Write a Python script containing encryption and decryption functions. By default, the script is named <code>encryptionDecryption.py</code> and resides in the Packet Ripper settings directory.</p> </li> <li> <p>Configure Settings: In the Packet Ripper settings, specify the path to the Python script and the names of the encryption and decryption functions.</p> </li> <li> <p>Integration with Proxy: Packet Ripper automatically calls the specified encryption or decryption function from the Python script, passing the intercepted network packet data as input.</p> </li> <li> <p>Customize Encryption/Decryption: Customize the encryption and decryption process in the Python script according to your security requirements and algorithms.</p> </li> </ol>"},{"location":"user-guide/api/#example-encryptiondecryption-script","title":"Example Encryption/Decryption Script","text":"<pre><code>    def encryptBuffers(buffers): # Encrypts buffers with xor, this function is called when resending packets\n      encrypted = []\n      for hex_string in buffers:\n        bytes_data = bytes.fromhex(hex_string)\n        encrypted_bytes = bytearray([b ^  0xFF  for b in bytes_data])\n        encrypted.append(encrypted_bytes.hex())\n      return buffers\n\n\n    def decrypt(buffers): # Simple XOR decryption function with parsing. Called When a packet is added to the proxy before the built in parser\n      decrypted_list = []\n      for hex_string in buffers:\n        bytes_data = bytes.fromhex(hex_string)\n        decrypted_bytes = bytearray([b ^  0xFF  for b in bytes_data])\n        decrypted_list.append(decrypted_bytes.hex())\\\n      for i in decrypted_list:\n        i = parse(decrypted_list)\n      return decrypted_list\n\n    def  parseShootPacket(buffer): # Parsing shoot Packet\n      return  \"Shoot packet\" # this is what shows in the the proxy now instead of the og buffer\n\n\n    def parseMovePacket(buffer):\n      buffer = buffer[4:]\n      x = float.fromhex(buffer[:8])\n      y = float.fromhex(buffer[8:16])\n      z = float.fromhex(buffer[16:24])\n      pitch = int.fromhex(buffer[24:26])\n      yaw = int.fromhex(buffer[26:28])\n      roll = int.fromhex(buffer[28:30])\n      parsed =  \"Move packet: x: \"  + str(x) +  \" y: \"  + str(y) +  \" z: \"  + str(z)\n      parsed +=  \" pitch: \"  + str(pitch) +  \" yaw: \"  + str(yaw) +  \" roll: \"  + str(roll)\n      return parsed\n\n\n  def parse(buffer): #decides what type of packet it is by opcode and calls corresponding parsing function\n      prefix = buffer[:4]\n      if prefix ==  \"6D76\":\n      return parseMovePacket(buffer)\n      elif prefix ==  \"2A69\":\n      return parseShootPacket(buffer)\n      return buffer\n</code></pre>"},{"location":"user-guide/hex-editor/","title":"Packet Ripper Hex Editor Documentation","text":"<p>Welcome to the Packet Ripper Hex Editor documentation! The hex editor feature in Packet Ripper allows you to view and modify hexadecimal data intercepted by the proxy. With the ability to edit hex directly and manipulate data types, the hex editor provides powerful capabilities for packet analysis and manipulation.</p>"},{"location":"user-guide/hex-editor/#introduction","title":"Introduction","text":"<p>The hex editor in Packet Ripper provides a user-friendly interface for examining and editing hexadecimal data. It offers two primary modes of operation: creating a new hex tab or editing hex data linked to a specific intercepted packet.</p>"},{"location":"user-guide/hex-editor/#viewing-hexadecimal-data","title":"Viewing Hexadecimal Data","text":"<p>Upon intercepting packets, the hexadecimal data is displayed in the textbox of the hex editor. Each byte of data is represented by two hexadecimal digits, allowing you to inspect the raw contents of the intercepted packets.</p>"},{"location":"user-guide/hex-editor/#editing-hexadecimal-data","title":"Editing Hexadecimal Data","text":"<p>To edit hexadecimal data, simply highlight the desired portion of the hexadecimal representation in the textbox and click the \"Edit Hex\" button. This enables you to modify the selected bytes directly, allowing for precise manipulation of packet contents.</p>"},{"location":"user-guide/hex-editor/#manipulating-data-types","title":"Manipulating Data Types","text":"<p>In addition to editing hex directly, the hex editor in Packet Ripper allows you to manipulate data types associated with the selected hex. The textbox at the bottom of the hex editor provides options for specifying the data type, such as integer, float, double, etc.</p>"},{"location":"user-guide/hex-editor/#creating-new-hex-tab","title":"Creating New Hex Tab","text":"<p>You can create a new hex tab by clicking the \"New Hex Tab\" button. This opens a new tab in the hex editor where you can enter hexadecimal data manually or paste data copied from external sources.</p>"},{"location":"user-guide/hex-editor/#editing-linked-packets","title":"Editing Linked Packets","text":"<p>Alternatively, you can right-click on a packet in the Packet Ripper Proxy interface and select the option to edit and resend the packet with the original socket options. This opens the hex editor with the hexadecimal data linked to the selected packet, allowing you to make modifications before resending the packet.</p>"},{"location":"user-guide/hex-editor/#updating-hexadecimal-data","title":"Updating Hexadecimal Data","text":"<p>After making changes to the hexadecimal representation or data types, click the \"Update Hex\" button to apply the changes to the intercepted packets. This ensures that the modified data is reflected in the packet stream, allowing for real-time packet manipulation.</p>"},{"location":"user-guide/hex-editor/#example","title":"Example","text":"<p>Here's an example of how to use the hex editor in Packet Ripper:</p> <ol> <li> <p>View Hex Data: Upon intercepting packets, the hexadecimal data is displayed in the hex editor textbox.</p> </li> <li> <p>Edit Hex: Highlight the desired portion of the hexadecimal representation and click the \"Edit Hex\" button to modify the selected bytes.</p> </li> <li> <p>Manipulate Data Types: Use the options in the data type selection box to specify the desired data type for the selected hex. For example we can type the number 4 in the integer field to update the selected hex with the correponding hex representation of the integer 4.</p> </li> <li> <p>Update Hex: After making changes, click the \"Update Hex\" button to apply the modifications to the intercepted packets.</p> </li> </ol>"},{"location":"user-guide/hex-editor/#conclusion","title":"Conclusion","text":"<p>The hex editor feature in Packet Ripper provides powerful capabilities for analyzing and manipulating hexadecimal data intercepted by the proxy. Whether you're inspecting packet contents, modifying data on-the-fly, or experimenting with different data types, the hex editor offers flexibility and control for packet analysis.</p> <p>For detailed instructions on using the hex editor feature, refer to the Packet Ripper documentation.</p>"},{"location":"user-guide/logger/","title":"Packet Ripper Logging Documentation","text":"<p>Welcome to the Packet Ripper Logging documentation! The logging feature in Packet Ripper allows you to monitor and analyze log messages generated by both the Packet Ripper program itself and the application injected into.</p>"},{"location":"user-guide/logger/#introduction","title":"Introduction","text":"<p>Packet Ripper provides two logging text fields: one for logging messages generated by the Packet Ripper program (local logs) and another for logging messages generated by the injected application (injected logs). These logs provide valuable insights into the operation of both Packet Ripper and the targeted application.</p>"},{"location":"user-guide/logger/#local-logs","title":"Local Logs","text":"<p>The local logs section displays log messages generated by the Packet Ripper program itself. These logs include information about the status of injection, packet resend operations, errors encountered during interception, and other important events related to Packet Ripper's operation.</p>"},{"location":"user-guide/logger/#injected-logs","title":"Injected Logs","text":"<p>The injected logs section displays log messages generated by the application injected into. These logs contain information about the status of packet resend operations initiated by Packet Ripper, errors encountered within the injected application, common requests such as HTTP requests, and any other logging done by the application.</p>"},{"location":"user-guide/logger/#usage","title":"Usage","text":"<p>To use the logging feature in Packet Ripper, follow these steps:</p> <ol> <li> <p>View Local Logs: Check the local logs section to monitor log messages generated by the Packet Ripper program.</p> </li> <li> <p>View Injected Logs: Check the injected logs section to monitor log messages generated by the application injected into.</p> </li> <li> <p>Analyze Log Messages: Analyze log messages to gain insights into the operation of both Packet Ripper and the injected application. Look for patterns, errors, or unusual behavior that may indicate issues or vulnerabilities.</p> </li> </ol>"},{"location":"user-guide/logger/#example","title":"Example","text":"<p>Here's an example of how to use the logging feature in Packet Ripper:</p> <ol> <li> <p>View Local Logs: Monitor local logs to check for status updates on injection, packet resend operations, and any errors encountered by Packet Ripper.</p> </li> <li> <p>View Injected Logs: Monitor injected logs to check for status updates on packet resend operations initiated by Packet Ripper, errors encountered within the injected application, and common requests such as HTTP requests.</p> </li> <li> <p>Analyze Log Messages: Analyze log messages to identify any issues or vulnerabilities in the targeted application's behavior. Look for errors, unusual patterns, or unexpected behavior that may require further investigation.</p> </li> </ol>"},{"location":"user-guide/logger/#conclusion","title":"Conclusion","text":"<p>The logging feature in Packet Ripper provides valuable insights into the operation of both Packet Ripper itself and the targeted application. By monitoring log messages generated by both the Packet Ripper program and the injected application, you can gain a deeper understanding of network traffic, identify issues or vulnerabilities, and optimize your packet interception and manipulation workflow.</p>"},{"location":"user-guide/parsers/","title":"Parser Documentation","text":"<p>Welcome to the Packet Ripper Parser documentation! The parser feature in Packet Ripper allows you to create custom rules for parsing specific types of packets intercepted by the proxy. This enables you to extract relevant information from intercepted packets and perform actions based on the parsed data.</p>"},{"location":"user-guide/parsers/#introduction","title":"Introduction","text":"<p>In network communication, packets often use opcodes to distinguish themselves and indicate the type of data they contain. For example, in a game network protocol, packets may have opcodes that represent different types of game events or data structures.</p> <p>For instance, consider a game where player positions are transmitted as packets. Each player position packet may have an opcode of 2576, and the next 12 bytes could represent the player's X, Y, and Z coordinates, each taking up 4 bytes.</p> <p>The parser in Packet Ripper leverages these opcodes to identify the type of data contained in intercepted packets and converts the hexadecimal representation into the desired data type with the specified size.</p>"},{"location":"user-guide/parsers/#parsing-and-packet-reconstruction","title":"Parsing and Packet Reconstruction","text":"<p>Once intercepted packets are parsed by the Packet Ripper parser, the parsed data can be displayed in a variety of formats, including a hex editor. This allows you to reconstruct packets visually and manipulate them as needed.</p> <p>For example, after parsing a player position packet with opcode 2576, the parser would extract the X, Y, and Z coordinates from the packet's hexadecimal representation. You can then view and modify these coordinates in the Hex-Editor, allowing you to adjust the player's position resend it to the game.</p>"},{"location":"user-guide/parsers/#enhanced-packet-analysis","title":"Enhanced Packet Analysis","text":"<p>In addition to packet reconstruction, the parser in Packet Ripper enables enhanced packet analysis by providing insights into the structure and content of intercepted packets. By defining parsing rules for specific packet types, you can extract meaningful information such as player actions, game events, or network protocol details.</p> <p>For instance, you could create parsing rules to identify and extract chat messages from game packets, allowing you to monitor in-game communication or detect suspicious activity.</p>"},{"location":"user-guide/parsers/#using-the-parser","title":"Using the Parser","text":"<p>To use the parser feature, follow these steps:</p> <ol> <li> <p>Define Parsing Rules: Create custom parsing rules specifying the packet opcodes and the desired data types and sizes.</p> </li> <li> <p>Intercept Packets: Enable the Packet Ripper Proxy to intercept network traffic and capture packets that match the defined parsing rules.</p> </li> <li> <p>Parse Intercepted Packets: The parser will automatically process intercepted packets according to the defined parsing rules, converting hexadecimal data into the specified data types.</p> </li> <li> <p>View Parsed Data: The parsed data will be displayed visually within the Packet Ripper interface, including the hex editor, allowing you to inspect and manipulate the packet contents as needed.</p> </li> </ol>"},{"location":"user-guide/parsers/#configuration","title":"Configuration","text":"<p>You can configure parsing rules in Packet Ripper by accessing the parser settings. Here, you can define the packet opcodes, specify the data types and sizes for parsing, and manage parsing rules. The enable option simply dictates wether the proxy will parse that specific data parser, however this will still show in the Hex-Editor when we want to resend. The ignore option makes it so the proxy ignores that specific type of packet that matches that opcode. This is particular useful when you only want to see packets you haven't discovered yet.</p>"},{"location":"user-guide/parsers/#example","title":"Example","text":"<p>Here's an example of how to create a parsing rule in Packet Ripper:</p> <ol> <li> <p>Define Rule: Specify the packet opcode to target and the data type and size for parsing (e.g., opcode <code>2576</code> represents player position data with X, Y, and Z coordinates each occupying 4 bytes)Notice how even though each float should take 4 bytes we have 8. This is due to the fact 1 byte is represented by 2 hex digits. Even though this might be a bit confusing, its necessary for the freedom when resending or parsing packets with uneven sizes.</p> </li> <li> <p>Intercept Packets: Enable the Packet Ripper Proxy to intercept packets containing the specified opcode.</p> </li> <li> <p>Parse Intercepted Packets: The parser will convert the hexadecimal data corresponding to the specified opcode into the desired data type with the specified size.</p> </li> <li> <p>View Parsed Data: The parsed data will be displayed within the Packet Ripper interface, including the hex editor, allowing you to view and interact with the parsed packet contents.</p> </li> </ol>"},{"location":"user-guide/parsers/#conclusion","title":"Conclusion","text":"<p>The parser feature in Packet Ripper provides powerful capabilities for analyzing and manipulating intercepted network packets. By defining custom parsing rules, you can extract valuable information from packet data and gain deeper insights into network communication.</p> <p>For detailed instructions on configuring parsing rules with the python api see here</p>"},{"location":"user-guide/proxy/","title":"Proxy","text":""},{"location":"user-guide/proxy/#introduction","title":"Introduction","text":"<p>The Packet Ripper Proxy feature intercepts various network functions, allowing you to analyze and modify network packets in real-time. Whether you're testing the security of network applications or debugging network issues, the Packet Ripper Proxy provides the flexibility and control you need.</p>"},{"location":"user-guide/proxy/#understanding-socket-types-and-winsock-versions","title":"Understanding Socket Types and Winsock Versions","text":""},{"location":"user-guide/proxy/#socket-types","title":"Socket Types","text":"<p>Sockets in network programming can be categorized into two main types: connected and unconnected. </p> <ul> <li> <p>Connected Sockets: These sockets are used in connection-oriented protocols, such as TCP. They establish a connection with another socket before transmitting data.</p> </li> <li> <p>Unconnected Sockets: These sockets are used in connectionless protocols, such as UDP. They do not establish a connection before transmitting data and can send data to multiple destinations without establishing a connection.</p> </li> </ul>"},{"location":"user-guide/proxy/#major-differences-between-winsock-and-winsock2-functions","title":"Major Differences between Winsock and Winsock2 Functions","text":"<p>Winsock (Windows Sockets 1.1) and Winsock2 (Windows Sockets 2.0) are both API specifications for network programming in Windows. While they share many similarities, there are some significant differences:</p> <ul> <li> <p>Protocol Support: Winsock2 supports additional protocols and features compared to Winsock, including multicast, quality of service (QoS), and overlapped I/O.</p> </li> <li> <p>Socket Handling: Winsock2 introduces a more robust socket handling model, including support for event-driven programming with overlapped I/O.</p> </li> <li> <p>Namespace: Winsock2 introduces a separate namespace (<code>WSA</code>) for its functions and data types to avoid conflicts with other Windows APIs.</p> </li> </ul> <p>For more detailed information about the differences between Winsock and Winsock2, refer to the Windows documentation.</p>"},{"location":"user-guide/proxy/#proxy-functions","title":"Proxy Functions","text":""},{"location":"user-guide/proxy/#sending-functions","title":"Sending Functions","text":"<p>The sending functions, such as <code>send</code> and <code>sendto</code>, are commonly used in TCP and UDP communication, respectively. While <code>send</code> is used on a connected socket, <code>sendto</code> allows sending data to a specific destination, making it suitable for both connected and unconnected sockets.</p> <ul> <li>Arguments (send):</li> <li><code>s</code>: A descriptor identifying a connected socket.</li> <li><code>buf</code>: A pointer to the buffer containing the data to be transmitted.</li> <li><code>len</code>: The length, in bytes, of the data in the buffer.</li> <li> <p><code>flags</code>: A set of flags that specify the way in which the call is made.</p> </li> <li> <p>Arguments (sendto):</p> </li> <li><code>s</code>: A descriptor identifying a socket.</li> <li><code>buf</code>: A pointer to the buffer containing the data to be transmitted.</li> <li><code>len</code>: The length, in bytes, of the data in the buffer.</li> <li><code>flags</code>: A set of flags that specify the way in which the call is made.</li> <li><code>to</code>: A pointer to the address of the target socket.</li> <li><code>tolen</code>: The size, in bytes, of the <code>to</code> buffer.</li> </ul> <p>For more information, refer to the Windows documentation for <code>send</code> and sendto.</p>"},{"location":"user-guide/proxy/#asynchronous-functions","title":"Asynchronous Functions","text":"<p>The asynchronous functions, such as <code>WSASend</code> and <code>WSASendTo</code>, provide extended options for buffer management and notification callbacks. These functions are commonly used in scenarios where non-blocking operations are required, allowing for efficient handling of network communication.</p> <ul> <li>Arguments (WSASend):</li> <li><code>s</code>: A descriptor identifying a connected socket.</li> <li><code>lpBuffers</code>: A pointer to an array of <code>WSABUF</code> structures.</li> <li><code>dwBufferCount</code>: The number of buffers in the array.</li> <li><code>lpNumberOfBytesSent</code>: A pointer to the number of bytes sent by this call.</li> <li><code>dwFlags</code>: A set of flags that modify the behavior of the function call.</li> <li> <p><code>lpOverlapped</code>: A pointer to a <code>WSAOVERLAPPED</code> structure.</p> </li> <li> <p>Arguments (WSASendTo):</p> </li> <li><code>s</code>: A descriptor identifying a socket.</li> <li><code>lpBuffers</code>: A pointer to an array of <code>WSABUF</code> structures.</li> <li><code>dwBufferCount</code>: The number of buffers in the array.</li> <li><code>lpNumberOfBytesSent</code>: A pointer to the number of bytes sent by this call.</li> <li><code>dwFlags</code>: A set of flags that modify the behavior of the function call.</li> <li><code>lpTo</code>: A pointer to the address of the target socket.</li> <li><code>iTolen</code>: The size, in bytes, of the <code>lpTo</code> buffer.</li> <li><code>lpOverlapped</code>: A pointer to a <code>WSAOVERLAPPED</code> structure.</li> </ul> <p>For more information, refer to the Windows documentation for <code>WSASend</code> and WSASendTo.</p>"},{"location":"user-guide/proxy/#receiving-functions","title":"Receiving Functions","text":"<p>The receiving functions, such as <code>recv</code> and <code>recvfrom</code>, are commonly used in TCP and UDP communication, respectively. While <code>recv</code> receives data from a connected socket, <code>recvfrom</code> receives data from a socket and retrieves the address of the sender.</p> <ul> <li>Arguments (recv):</li> <li><code>s</code>: A descriptor identifying a connected socket.</li> <li><code>buf</code>: A pointer to the buffer to receive the incoming data.</li> <li><code>len</code>: The length, in bytes, of the buffer.</li> <li> <p><code>flags</code>: A set of flags that specify the way in which the call is made.</p> </li> <li> <p>Arguments (recvfrom):</p> </li> <li><code>s</code>: A descriptor identifying a socket.</li> <li><code>buf</code>: A pointer to the buffer to receive the incoming data.</li> <li><code>len</code>: The length, in bytes, of the buffer.</li> <li><code>flags</code>: A set of flags that specify the way in which the call is made.</li> <li><code>from</code>: An optional pointer to a <code>SOCKADDR</code> structure that receives the address of the sender.</li> <li><code>fromlen</code>: An optional pointer to the size, in bytes, of the <code>from</code> buffer.</li> </ul> <p>For more information, refer to the Windows documentation for <code>recv</code> and recvfrom.</p>"},{"location":"user-guide/proxy/#asynchronous-receiving-functions","title":"Asynchronous Receiving Functions","text":"<p>The asynchronous receiving functions, such as <code>WSARecv</code> and <code>WSARecvFrom</code>, offer advanced buffer management and notification options. These functions are commonly used in scenarios where non-blocking operations are required for efficient handling of incoming data.</p> <ul> <li>Arguments (WSARecv):</li> <li><code>s</code>: A descriptor identifying a connected socket.</li> <li><code>lpBuffers</code>: A pointer to an array of <code>WSABUF</code> structures.</li> <li><code>dwBufferCount</code>: The number of buffers in the array.</li> <li><code>lpNumberOfBytesRecvd</code>: A pointer to the number of bytes received by this call.</li> <li><code>lpFlags</code>: A pointer to flags that provide additional information about the receive operation.</li> <li> <p><code>lpOverlapped</code>: A pointer to a <code>WSAOVERLAPPED</code> structure.</p> </li> <li> <p>Arguments (WSARecvFrom):</p> </li> <li><code>s</code>: A descriptor identifying a socket.</li> <li><code>lpBuffers</code>: A pointer to an array of <code>WSABUF</code> structures.</li> <li><code>dwBufferCount</code>: The number of buffers in the array.</li> <li><code>lpNumberOfBytesRecvd</code>: A pointer to the number of bytes received by this call.</li> <li><code>lpFlags</code>: A pointer to flags that provide additional information about the receive operation.</li> <li><code>lpFrom</code>: An optional pointer to a <code>SOCKADDR</code> structure that receives the address of the sender.</li> <li><code>lpFromLen</code>: An optional pointer to the size, in bytes, of the <code>lpFrom</code> buffer.</li> </ul> <p>For more information, refer to the Windows documentation for <code>WSARecv</code> and WSARecvFrom.</p>"},{"location":"user-guide/proxy/#usage","title":"Usage","text":"<p>To use the Packet Ripper Proxy feature, simply enable it in the Packet Ripper interface. Once enabled, the proxy will intercept network traffic according to the specified filters and rules.</p>"},{"location":"user-guide/proxy/#packet-parsing","title":"Packet Parsing","text":"<p>Additionally, you can utilize the parser feature in Packet Ripper to create custom rules for parsing specific types of packets intercepted by the proxy. This allows you to extract relevant information from the intercepted packets and perform actions based on the parsed data. For detailed instructions on configuring packet parsing rules, refer to the parsers section or the python api section.</p>"},{"location":"user-guide/proxy/#configuration","title":"Configuration","text":"<p>You can configure the Packet Ripper Proxy settings to define which network functions to intercept and how to handle intercepted packets. Refer to the Packet Ripper documentation for detailed configuration instructions.</p>"},{"location":"user-guide/injector/","title":"Packet Ripper Injector Documentation","text":"<p>Welcome to the Packet Ripper Injector Documentation! This documentation provides detailed information on how to use the Packet Ripper Injector, a powerful tool for injecting code into target applications to intercept and manipulate network traffic.</p>"},{"location":"user-guide/injector/#overview","title":"Overview","text":"<p>The Packet Ripper Injector is a versatile tool designed to inject custom code into target applications, allowing for the interception and manipulation of network traffic. By injecting code directly into the application's memory space, the Injector provides granular control over network communication, enabling various security testing and analysis tasks like seamlessly resending packets.</p>"},{"location":"user-guide/injector/#key-features","title":"Key Features","text":"<ul> <li>Network Interception: Intercept network traffic between the target application and external servers to analyze communication protocols and data exchanges.</li> <li>Packet Manipulation: Modify intercepted packets on-the-fly to simulate different network conditions, test for vulnerabilities, or perform protocol analysis.</li> <li>Dynamic Analysis: Gain insights into the runtime behavior of target applications by injecting custom code snippets for logging, debugging, or instrumentation purposes.</li> <li>Real-Time Monitoring: Monitor network traffic in real-time, enabling rapid response to security incidents, performance issues, or unexpected behavior.</li> <li>Customizable: Customize the injected code to suit specific testing scenarios, application environments, or protocol requirements.</li> </ul>"},{"location":"user-guide/injector/#note-for-users","title":"Note for Users","text":"<p>The Packet Ripper Injector offers a comprehensive set of features and functionalities, and it's not necessary to delve into the flags or default injection settings for most programs. However, for some programs with detection mechanisms, we provided various types of launch methods, injecting methods, cloaking, manual mapping, etc., to ensure optimal performance and stealthiness.</p>"},{"location":"user-guide/injector/#conclusion","title":"Conclusion","text":"<p>The Packet Ripper Injector is a powerful tool for network analysis, security testing, and dynamic analysis of applications. With its ability to inject code directly into target processes, the Injector provides unparalleled visibility and control over network communication, empowering users to uncover vulnerabilities, analyze protocols, and enhance application security.</p> <p>For detailed instructions on using the Packet Ripper Injector, refer to the documentation sections below.</p>"},{"location":"user-guide/injector/flags/","title":"Cloaking and Manual Mapping Options in Packet Ripper","text":"<p>Packet Ripper offers a range of cloaking and manual mapping options to enhance the stealthiness and effectiveness of the injection process. These options provide users with the flexibility to customize the injection behavior based on specific requirements and scenarios.</p>"},{"location":"user-guide/injector/flags/#introduction","title":"Introduction","text":"<p>Cloaking and manual mapping options in Packet Ripper allow users to manipulate various aspects of the injection process, from altering DLL headers to executing specific callbacks and initializing security mechanisms. By understanding and leveraging these options, users can enhance the stealthiness and resilience of their injection techniques.</p>"},{"location":"user-guide/injector/flags/#cloaking-options","title":"Cloaking Options","text":"<p>Cloaking options in Packet Ripper focus on modifying the characteristics of the injected DLL to evade detection and analysis by anti-cheat systems and security software. Flags such as INJ_ERASE_HEADER and INJ_FAKE_HEADER allow users to manipulate the DLL's header, while others like INJ_UNLINK_FROM_PEB and INJ_THREAD_CREATE_CLOAKED aim to make the injection process more stealthy and difficult to detect.</p>"},{"location":"user-guide/injector/flags/#inj_erase_header","title":"INJ_ERASE_HEADER","text":"<ul> <li>Description: Replaces the first 0x1000 bytes of the DLL with zeros, effectively erasing its header.</li> <li>Advantages:</li> <li>Helps evade detection by altering the DLL's header, making it appear as if it lacks a valid PE header.</li> <li>Considerations:</li> <li>May lead to instability or crashes if critical header information is overwritten.</li> <li>Detection may still be possible through other means, such as behavioral analysis.</li> </ul>"},{"location":"user-guide/injector/flags/#inj_fake_header","title":"INJ_FAKE_HEADER","text":"<ul> <li>Description: Replaces the DLL's header with the header of the <code>ntdll.dll</code>.</li> <li>Advantages:</li> <li>Mimics the header of a legitimate system DLL, making the injected DLL appear more authentic.</li> <li>Considerations:</li> <li>May trigger detection mechanisms that compare DLL headers with known system DLLs.</li> <li>Requires careful handling to ensure compatibility with the target environment.</li> </ul>"},{"location":"user-guide/injector/flags/#inj_unlink_from_peb","title":"INJ_UNLINK_FROM_PEB","text":"<ul> <li>Description: Unlinks the module from the process environment block (PEB).</li> <li>Advantages:</li> <li>Removes traces of the injected module from process-related data structures, reducing detectability.</li> <li>Considerations:</li> <li>Ignored when manually mapping, limiting its effectiveness in certain scenarios.</li> <li>May be ineffective against advanced detection techniques that analyze memory contents.</li> </ul>"},{"location":"user-guide/injector/flags/#inj_thread_create_cloaked","title":"INJ_THREAD_CREATE_CLOAKED","text":"<ul> <li>Description: Passes certain flags to <code>NtCreateThreadEx</code> to make the thread creation more stealthy.</li> <li>Advantages:</li> <li>Enhances the stealthiness of thread creation, making it harder to detect by anti-cheat systems.</li> <li>Considerations:</li> <li>Requires the launch method to be NtCreateThreadEx; ignored otherwise.</li> <li>May increase the complexity of the injection process and lead to compatibility issues.</li> </ul>"},{"location":"user-guide/injector/flags/#inj_scramble_dll_name","title":"INJ_SCRAMBLE_DLL_NAME","text":"<ul> <li>Description: Randomizes the DLL name on disk before injecting it.</li> <li>Advantages:</li> <li>Helps obfuscate the injected DLL's identity, making it harder to attribute to the injector.</li> <li>Considerations:</li> <li>May cause confusion during debugging or troubleshooting.</li> <li>Requires additional measures to maintain track of injected DLLs for management purposes.</li> </ul>"},{"location":"user-guide/injector/flags/#inj_load_dll_copy","title":"INJ_LOAD_DLL_COPY","text":"<ul> <li>Description: Loads a copy of the DLL from the <code>%temp%</code> directory.</li> <li>Advantages:</li> <li>Prevents tampering with the original DLL file, preserving its integrity.</li> <li>Considerations:</li> <li>May raise suspicion if the injected DLL suddenly appears in the temporary directory.</li> <li>Requires sufficient permissions to create and execute files in the temporary directory.</li> </ul>"},{"location":"user-guide/injector/flags/#inj_hijack_handle","title":"INJ_HIJACK_HANDLE","text":"<ul> <li>Description: Tries to hijack a handle from another process instead of using <code>OpenProcess</code>.</li> <li>Advantages:</li> <li>Avoids direct interaction with the target process, reducing the likelihood of detection.</li> <li>Considerations:</li> <li>Relies on the availability of suitable handles in other processes, which may not always be feasible.</li> <li>May lead to unpredictable behavior if the hijacked handle becomes invalid or inaccessible.</li> </ul>"},{"location":"user-guide/injector/flags/#manual-mapping-options","title":"Manual Mapping Options","text":"<p>Manual mapping options in Packet Ripper provide advanced techniques for injecting code into the target process's memory space. These options offer granular control over the injection process, allowing users to resolve imports, execute callbacks, and initialize security features manually. Flags such as INJ_MM_SET_PAGE_PROTECTIONS and INJ_MM_SHIFT_MODULE_BASE enable users to fine-tune the injection behavior for optimal performance and stealthiness.</p>"},{"location":"user-guide/injector/flags/#manual-mapping-options_1","title":"Manual Mapping Options","text":""},{"location":"user-guide/injector/flags/#inj_mm_clean_data_dir","title":"INJ_MM_CLEAN_DATA_DIR","text":"<ul> <li>Description: Removes data from the DLL's PE header.</li> <li>Advantages:</li> <li>Reduces the footprint of the injected DLL, minimizing the likelihood of detection.</li> <li>Considerations:</li> <li>Ignored if INJ_MM_SET_PAGE_PROTECTIONS is set, limiting its applicability in certain scenarios.</li> <li>May interfere with the functionality of the injected DLL if critical data is removed.</li> </ul>"},{"location":"user-guide/injector/flags/#inj_mm_resolve_imports","title":"INJ_MM_RESOLVE_IMPORTS","text":"<ul> <li>Description: Resolves DLL imports.</li> <li>Advantages:</li> <li>Ensures that the injected DLL has access to all required external functions and libraries.</li> <li>Considerations:</li> <li>Increases the size of the injected code and may prolong the injection process.</li> <li>Requires access to the target process's address space to resolve imports successfully.</li> </ul>"},{"location":"user-guide/injector/flags/#inj_mm_resolve_delay_imports","title":"INJ_MM_RESOLVE_DELAY_IMPORTS","text":"<ul> <li>Description: Resolves delayed imports.</li> <li>Advantages:</li> <li>Handles imports that are resolved dynamically at runtime, ensuring smooth execution of the injected code.</li> <li>Considerations:</li> <li>Adds complexity to the injection process and may introduce overhead.</li> <li>Requires careful handling to ensure compatibility with the target environment.</li> </ul>"},{"location":"user-guide/injector/flags/#inj_mm_execute_tls","title":"INJ_MM_EXECUTE_TLS","text":"<ul> <li>Description: Executes TLS callbacks and initializes static TLS data.</li> <li>Advantages:</li> <li>Ensures proper initialization of Thread Local Storage (TLS) data, maintaining the integrity of the injected code.</li> <li>Considerations:</li> <li>May increase the execution time of the injection process, especially if multiple TLS callbacks are present.</li> <li>Requires thorough testing to verify compatibility with the target process's TLS initialization routine.</li> </ul>"},{"location":"user-guide/injector/flags/#inj_mm_enable_exceptions","title":"INJ_MM_ENABLE_EXCEPTIONS","text":"<ul> <li>Description: Enables exception handling.</li> <li>Advantages:</li> <li>Improves the robustness of the injected code by allowing it to handle unexpected errors or exceptions.</li> <li>Considerations:</li> <li>Adds overhead to the injection process and may impact performance.</li> <li>Requires careful error handling to prevent unintended behavior or crashes.</li> </ul>"},{"location":"user-guide/injector/flags/#inj_mm_set_page_protections","title":"INJ_MM_SET_PAGE_PROTECTIONS","text":"<ul> <li>Description: Sets page protections based on section characteristics.</li> <li>Advantages:</li> <li>Enhances the security of the injected code by restricting access to certain memory regions.</li> <li>Considerations:</li> <li>Overrides INJ_MM_CLEAN_DATA_DIR if set, limiting the effectiveness of data directory cleaning.</li> <li>Requires thorough understanding of memory protection mechanisms to avoid unintended consequences.</li> </ul>"},{"location":"user-guide/injector/flags/#inj_mm_init_security_cookie","title":"INJ_MM_INIT_SECURITY_COOKIE","text":"<ul> <li>Description: Initializes security cookie for buffer overrun protection.</li> <li>Advantages:</li> <li>Strengthens the security posture of the injected code by mitigating buffer overflow vulnerabilities.</li> <li>Considerations:</li> <li>Requires compiler support for security cookie generation and validation.</li> <li>May increase the size of the injected code and impact performance.</li> </ul>"},{"location":"user-guide/injector/flags/#inj_mm_run_dll_main","title":"INJ_MM_RUN_DLL_MAIN","text":"<ul> <li>Description: Executes DllMain; induces INJ_MM_RESOLVE_IMPORTS.</li> <li>Advantages:</li> <li>Ensures proper initialization of the injected DLL, including module attachment and detachment.</li> <li>Considerations:</li> <li>May trigger unwanted side effects if the DllMain function is not implemented correctly.</li> <li>Requires thorough testing to verify compatibility with the target process's initialization routine.</li> </ul>"},{"location":"user-guide/injector/flags/#inj_mm_run_under_ldr_lock","title":"INJ_MM_RUN_UNDER_LDR_LOCK","text":"<ul> <li>Description: Runs the DllMain under the loader lock.</li> <li>Advantages:</li> <li>Provides synchronization and thread safety during DLL initialization, reducing the risk of concurrency issues.</li> <li>Considerations:</li> <li>Requires careful handling to avoid deadlocks or race conditions.</li> <li>May introduce performance overhead, especially in multi-threaded environments.</li> </ul>"},{"location":"user-guide/injector/flags/#inj_mm_shift_module_base","title":"INJ_MM_SHIFT_MODULE_BASE","text":"<ul> <li>Description: Shifts the module base by a random offset.</li> <li>Advantages:</li> <li>Mitigates address space layout randomization (ASLR) bypass techniques by introducing additional entropy.</li> <li>Considerations:</li> <li>May lead to compatibility issues with certain DLLs or modules that rely on fixed memory addresses.</li> <li>Requires careful handling to ensure proper alignment and avoid memory conflicts.</li> </ul>"},{"location":"user-guide/injector/flags/#summary","title":"Summary","text":"<p>Cloaking and manual mapping options in Packet Ripper empower users to customize the injection process according to their specific needs and objectives. Whether it's erasing DLL headers to evade detection or executing TLS callbacks for initialization, these options offer a comprehensive toolkit for enhancing the stealthiness and effectiveness of injection techniques in various scenarios.</p>"},{"location":"user-guide/injector/injecting-methods/","title":"Injection Methods in Packet Ripper","text":"<p>Packet Ripper offers various injection methods, each designed to inject code or DLLs into target processes for the purpose of intercepting and manipulating network traffic.</p>"},{"location":"user-guide/injector/injecting-methods/#im_loadlibraryexw","title":"IM_LoadLibraryExW","text":"<ul> <li>Description: Injects a DLL into the target process using the <code>LoadLibraryExW</code> Windows API function.</li> <li>Methodology: Creates a remote thread in the target process, calling <code>LoadLibraryExW</code> with the DLL path.</li> <li>Advantages:</li> <li>Widely supported and compatible with various Windows versions.</li> <li>Less likely to be detected by antivirus software due to common usage.</li> </ul>"},{"location":"user-guide/injector/injecting-methods/#im_ldrloaddll","title":"IM_LdrLoadDll","text":"<ul> <li>Description: Injects a DLL into the target process using the <code>LdrLoadDll</code> Windows API function.</li> <li>Methodology: Utilizes the process environment block (PEB) to locate <code>LdrLoadDll</code> and calls it to load the DLL.</li> <li>Advantages:</li> <li>Less likely to be detected by antivirus software compared to <code>LoadLibraryExW</code>.</li> <li>Provides more control over the injection process.</li> </ul>"},{"location":"user-guide/injector/injecting-methods/#im_ldrploaddll","title":"IM_LdrpLoadDll","text":"<ul> <li>Description: Injects a DLL into the target process by directly calling the internal function <code>LdrpLoadDll</code>.</li> <li>Methodology: Bypasses documented API functions and directly calls internal Loader functions.</li> <li>Advantages:</li> <li>Provides deeper control and customization over the injection process.</li> <li>Less likely to be detected by traditional antivirus software.</li> </ul>"},{"location":"user-guide/injector/injecting-methods/#im_ldrploaddllinternal","title":"IM_LdrpLoadDllInternal","text":"<ul> <li>Description: Injects a DLL into the target process by manually mapping it into memory and invoking internal Loader functions.</li> <li>Methodology: Offers a manual approach to bypassing documented API functions entirely.</li> <li>Advantages:</li> <li>Offers the highest level of control and customization over the injection process.</li> <li>Can bypass certain security mechanisms by avoiding documented API functions.</li> </ul>"},{"location":"user-guide/injector/injecting-methods/#im_manualmap","title":"IM_ManualMap","text":"<ul> <li>Description: Manually maps a DLL into the target process's memory space without relying on the Windows Loader.</li> <li>Methodology: Parses the DLL file manually, resolves dependencies, and maps sections into memory.</li> <li>Advantages:</li> <li>Completely bypasses the Windows Loader, making it highly stealthy and difficult to detect.</li> <li>Provides full control over the injection process, including custom memory allocation and relocation.</li> </ul>"},{"location":"user-guide/injector/injecting-methods/#summary","title":"Summary","text":"<p>Each injection method in Packet Ripper offers unique advantages for injecting code or DLLs into target processes, providing users with flexibility and control over the injection process. From leveraging standard Windows API functions to bypassing the Windows Loader entirely, Packet Ripper's injection methods cater to diverse use cases and security requirements.</p>"},{"location":"user-guide/injector/launch-methods/","title":"Launch Methods in Packet Ripper","text":"<p>Launch methods in Packet Ripper are essential techniques used to execute injected code within the context of a target process, enabling the interception and manipulation of network traffic. Let's explore each launch method in detail:</p>"},{"location":"user-guide/injector/launch-methods/#lm_ntcreatethreadex","title":"LM_NtCreateThreadEx","text":"<ul> <li>Description: Launches the injected code in the target process using the <code>NtCreateThreadEx</code> system call, which creates a new thread.</li> <li>Methodology: This method involves invoking <code>NtCreateThreadEx</code> with the address of the injected code as the start routine, effectively creating a new thread in the target process to execute the injected code.</li> <li>Advantages:</li> <li>Provides direct control over thread creation and execution, allowing for precise injection timing and synchronization.</li> <li>Utilizes native Windows API functions, making it less suspicious and more compatible with various Windows versions.</li> <li>Considerations:</li> <li>Requires sufficient permissions to create a new thread in the target process.</li> <li>May be detected by anti-cheat systems or security software due to the creation of new threads.</li> </ul>"},{"location":"user-guide/injector/launch-methods/#lm_hijackthread","title":"LM_HijackThread","text":"<ul> <li>Description: Hijacks an existing thread in the target process and redirects its execution flow to the injected code.</li> <li>Methodology: This method involves suspending a thread in the target process, modifying its context to point to the injected code, and then resuming its execution.</li> <li>Advantages:</li> <li>Stealthy approach as it utilizes existing threads in the target process, making detection more challenging.</li> <li>Can be effective in scenarios where creating new threads is suspicious or blocked.</li> <li>Considerations:</li> <li>Requires careful handling of thread context and synchronization to avoid stability issues or crashes.</li> <li>May trigger anti-cheat mechanisms or security software that monitor thread behavior.</li> </ul>"},{"location":"user-guide/injector/launch-methods/#lm_setwindowshookex","title":"LM_SetWindowsHookEx","text":"<ul> <li>Description: Installs a system-wide hook procedure to intercept events in the target process and trigger the execution of the injected code.</li> <li>Methodology: This method registers a hook procedure using the <code>SetWindowsHookEx</code> function, which gets called whenever the specified event occurs.</li> <li>Advantages:</li> <li>Allows for interception of specific events in the target process, such as keyboard or mouse input.</li> <li>Can be used for stealthy injection by leveraging legitimate Windows API functions.</li> <li>Considerations:</li> <li>Limited to events supported by the Windows hook mechanism, which may restrict its applicability.</li> <li>May be detected by anti-cheat systems or security software that monitor hooking activity.</li> </ul>"},{"location":"user-guide/injector/launch-methods/#lm_queueuserapc","title":"LM_QueueUserAPC","text":"<ul> <li>Description: Queues a user-mode asynchronous procedure call (APC) to a thread in the target process, causing it to execute the injected code.</li> <li>Methodology: This method leverages the <code>QueueUserAPC</code> function to add a user-defined APC to the APC queue of the target thread.</li> <li>Advantages:</li> <li>Utilizes a legitimate Windows API function for injection, making it less suspicious.</li> <li>Can be effective in scenarios where direct thread creation is not feasible or permitted.</li> <li>Considerations:</li> <li>Requires a target thread to be in an alertable state to process the queued APC.</li> <li>May be detected by anti-cheat systems or security software that monitor APC activity.</li> </ul>"},{"location":"user-guide/injector/launch-methods/#lm_kernelcallback","title":"LM_KernelCallback","text":"<ul> <li>Description: Leverages kernel-mode callback mechanisms to execute the injected code in the context of the target process.</li> <li>Methodology: This method involves registering a kernel-mode callback routine that gets called in response to specific system events or triggers.</li> <li>Advantages:</li> <li>Operates at a lower privilege level, making it more difficult to detect or interfere with.</li> <li>Can be used for stealthy injection by hooking into legitimate kernel events.</li> <li>Considerations:</li> <li>Requires kernel-mode programming knowledge and may lead to system instability if not implemented correctly.</li> <li>May trigger security mechanisms or anti-cheat systems that monitor kernel activity.</li> </ul>"},{"location":"user-guide/injector/launch-methods/#lm_fakeveh","title":"LM_FakeVEH","text":"<ul> <li>Description: Simulates the behavior of a legitimate Vectored Exception Handler (VEH) to execute the injected code in the target process.</li> <li>Methodology: This method installs a fake VEH that intercepts and handles exception events, redirecting the execution flow to the injected code.</li> <li>Advantages:</li> <li>Mimics the behavior of legitimate exception handling mechanisms, making detection more challenging.</li> <li>Can be effective in bypassing certain anti-injection techniques or detection mechanisms.</li> <li>Considerations:</li> <li>Requires careful handling of exception events and may lead to instability or crashes if not implemented correctly.</li> <li>May still be detected by advanced anti-cheat systems or security software that monitor exception handling behavior.</li> </ul>"},{"location":"user-guide/injector/launch-methods/#summary","title":"Summary","text":"<p>Each launch method in Packet Ripper offers unique advantages and considerations for executing injected code within target processes. By carefully selecting the appropriate launch method based on the specific requirements and constraints of the target environment, users can enhance the stealthiness and effectiveness of their network interception and manipulation activities.</p>"}]}